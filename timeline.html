<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OC Timeline Manager</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <!-- vis-timeline styles -->
  <link 
    href="https://unpkg.com/vis-timeline@latest/styles/vis-timeline-graph2d.min.css" 
    rel="stylesheet" />
  <style>
    body { margin:0; display:flex; height:100vh; font-family:Arial,sans-serif; }
    #sidebar {
      width:300px; padding:16px; box-sizing:border-box;
      border-right:1px solid #ccc; background:#fff; overflow-y:auto;
    }
    #sidebar h2 { margin-top:0; color:#4a90e2; }
    #sidebar label { display:block; margin-top:12px; font-weight:bold; }
    #sidebar input, #sidebar select, #sidebar button {
      width:100%; margin-top:4px; padding:6px; box-sizing:border-box;
    }
    #sidebar button { background:#4a90e2; color:#fff; border:none; cursor:pointer; }
    #main {
      flex:1; display:flex; flex-direction:column;
    }
    #controls {
      padding:8px; background:#f4f4f4; border-bottom:1px solid #ccc;
      display:flex; align-items:center; gap:12px;
    }
    #controls label { margin:0; }
    #timeline { flex:1; }
  </style>
</head>
<body>

  <div id="sidebar">
    <h2>OCs</h2>
    <label>Name</label>
    <input id="ocName" placeholder="Character name…" />
    <label>Color</label>
    <input id="ocColor" type="color" value="#e74c3c"/>
    <button id="addOc">Add OC</button>

    <hr/>

    <h2>Events</h2>
    <p>Double-click on the timeline to add or edit events.</p>
    <small>No need to pre-tag an OC—tags are optional in the editor.</small>
  </div>

  <div id="main">
    <div id="controls">
      <label for="zoom">Zoom:</label>
      <input type="range" id="zoom" min="1" max="50" value="10"/>
      <span id="zoomVal">10 px/yr</span>
    </div>
    <div id="timeline"></div>
  </div>

  <!-- vis-timeline library -->
  <script src="https://unpkg.com/vis-timeline@latest/standalone/umd/vis-timeline-graph2d.min.js"></script>
  <script>
    // ── Persistence Keys ──
    const KEY_OC   = 'tl_ocs';
    const KEY_EVT  = 'tl_events';
    const KEY_ZOOM = 'tl_zoom';

    // ── Load/Save Helpers ──
    function save(key, val){ localStorage.setItem(key, JSON.stringify(val)); }
    function load(key, def){ 
      try { return JSON.parse(localStorage.getItem(key)) ?? def; }
      catch{ return def; }
    }

    // ── State ──
    let OCs    = load(KEY_OC, []);
    let events = load(KEY_EVT, []);
    let zoom   = load(KEY_ZOOM, 10);

    // ── UI Elements ──
    const ocNameIn = document.getElementById('ocName');
    const ocColorIn= document.getElementById('ocColor');
    const addOcBtn = document.getElementById('addOc');
    const zoomIn   = document.getElementById('zoom');
    const zoomVal  = document.getElementById('zoomVal');
    const container= document.getElementById('timeline');

    // ── DataSets ──
    const ocDataset   = new vis.DataSet(OCs.map((o,i)=>({ id:i, content:o.name, className:'' })));
    const eventItems  = new vis.DataSet(events);

    // ── Timeline Setup ──
    const timeline = new vis.Timeline(container, eventItems, {
      editable: {
        add: true,
        updateTime: true,
        updateGroup: false,
        remove: true
      },
      orientation: 'bottom',
      zoomable: true,
      moveable: true,
      stack: true,
      // ctrl+wheel to zoom, wheel alone to scroll page
      interaction: { zoomKey: 'ctrlKey' },
      min: new Date(-1e12),
      max: new Date(1e12),
      moment: function(date) {
        return vis.moment(date).utc();  // ensure UTC for consistency
      },
      template: function(item) {
        // Optional: include OC color next to title
        const oc = OCs[item.ocIndex];
        const dot = oc ? `<span style="color:${oc.color}">●</span> ` : '';
        return dot + item.content;
      }
    });

    // ── Wire Up OCs Panel ──
    addOcBtn.onclick = () => {
      const name  = ocNameIn.value.trim();
      const color = ocColorIn.value;
      if(!name) return alert('OC name is required');
      const id = OCs.length;
      OCs.push({ name, color });
      ocDataset.add({ id, content:name });
      save(KEY_OC, OCs);
      ocNameIn.value = '';
    };

    // ── Zoom Slider ──
    zoomIn.value = zoom;
    zoomVal.textContent = zoom + ' px/yr';
    zoomIn.oninput = () => {
      zoom = +zoomIn.value;
      zoomVal.textContent = zoom + ' px/yr';
      timeline.setOptions({ zoomMin: zoom * 10, zoomMax: zoom * 1000000 });
      timeline.setWindow(timeline.getWindow().start, timeline.getWindow().end, { animate: false });
      save(KEY_ZOOM, zoom);
    };

    // ── Event add/update/remove Handlers ──
    timeline.on('add', function (props, callback) {
      // prompt user for details
      const content = prompt('Event title:', '');
      if(!content) return callback(null);
      const dateStr = prompt('Date (YYYY-MM-DD or YYYY-MM-DDTHH:mm):', 
                             vis.moment(props.start).utc().format('YYYY-MM-DD'));
      const date = dateStr ? new Date(dateStr) : props.start;
      const desc = prompt('Description (optional):', '') || '';
      const ocIdx = prompt('Tag OC index (optional):', '') ;
      const ocIndex = ocIdx !== '' && !isNaN(+ocIdx) ? +ocIdx : null;

      const newItem = {
        id: Date.now(),
        content,
        start: date,
        description: desc,
        ocIndex
      };
      eventItems.add(newItem);
      events.push(newItem);
      save(KEY_EVT, events);
      callback(newItem);
    });

    timeline.on('change', function (props, callback) {
      // props.items = [id]
      // update underlying `events`
      props.items.forEach(id => {
        const it = eventItems.get(id);
        const idx = events.findIndex(e=>e.id===id);
        if(idx >= 0) events[idx] = it;
      });
      save(KEY_EVT, events);
      callback(props);
    });

    timeline.on('remove', function (props, callback) {
      props.items.forEach(id => {
        events = events.filter(e=>e.id!==id);
      });
      save(KEY_EVT, events);
      callback(props);
    });

    // ── Initialize Zoom Bounds ──
    timeline.setOptions({
      zoomMin: zoom * 10,
      zoomMax: zoom * 1000000
    });
  </script>
</body>
</html>
